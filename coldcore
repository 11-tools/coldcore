#!/usr/bin/env python3
"""
TODO

- [ ] curses control panel
- [ ] add version birthday to new config
- [ ] handle overflow in curses balance panel
- [ ] port curses onboarding flow to non-curses
- [ ] colorize UI
- [ ] implement --json, --csv
- [ ] implement command-on-monitor
- [ ] allow manual coin selection when sending
- [ ] address labeling

To document:

- [ ] config


Security assumptions:

- xpub is stored in Core unencrypted

"""

import logging
import re
import typing as t
import sys
import base64
import datetime
import subprocess
import time
import socket
import threading
import textwrap
import json
import io
import os
from pathlib import Path
from typing import Optional as Op
from dataclasses import dataclass, field
from configparser import ConfigParser
from decimal import Decimal



"""
clii

The easiest damned argparse wrapper there ever was.


Copyright 2020 James O'Beirne

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import sys
import argparse
import functools
import inspect
import typing as t
import os
import logging
from textwrap import dedent


logger = logging.getLogger("clii")
if os.environ.get("CLII_DEBUG"):
    logger.setLevel(logging.DEBUG)
    logger.addHandler(logging.StreamHandler())


class Arg:
    def __init__(
        self,
        name_or_flags: t.Union[str, t.Sequence[str]],
        type: object = str,
        help: str = "",
        default: object = inspect.Parameter.empty,
        is_kwarg: bool = False,
        is_vararg: bool = False,
        dest: t.Optional[str] = None,
    ):
        names: t.List[str] = (
            [name_or_flags] if isinstance(name_or_flags, str) else list(name_or_flags)
        )

        # Store original parameter name unmangled (e.g. no '-' for '_' sub).
        self.dest = dest or names[0]

        if is_kwarg:
            names = [n.replace("_", "-") for n in names]

        self.name = names[0]
        self.all_names = list(names)
        self.type = type
        self.default = default
        self.is_kwarg = is_kwarg
        self.is_vararg = is_vararg
        self.help = help

    @classmethod
    def from_parameter(cls, param: inspect.Parameter, help: str = "") -> "Arg":
        type = param.annotation
        arg = None

        def is_kwarg(p):
            return p.default != inspect.Parameter.empty

        if isinstance(type, cls):
            # User already specified an Arg, just use that.
            arg = type
            arg.is_kwarg = is_kwarg(param)
            arg.default = param.default
            arg.update_name(param.name)
            arg.dest = param.name
            return arg
        return cls(
            param.name,
            type=param.annotation,
            default=param.default,
            help=help,
            is_kwarg=is_kwarg(param),
            is_vararg=(param.kind == inspect.Parameter.VAR_POSITIONAL),
            dest=param.name,
        )

    @classmethod
    def from_func(cls, func: t.Callable) -> t.Sequence["Arg"]:
        # Ignore `**kwargs`; it can't be sensibly interpreted into flags
        params = [
            p for p in _get_func_params(func) if p.kind != inspect.Parameter.VAR_KEYWORD
        ]

        helps_from_doc = _get_helps_from_func(func, [p.name for p in params])

        return tuple(
            cls.from_parameter(param, helps_from_doc.get(param.name, ""))
            for param in _get_func_params(func)
            if
            # Ignore `**kwargs`; it can't be sensibly interpreted into flags
            param.kind != inspect.Parameter.VAR_KEYWORD
        )

    def add_to_parser(self, parser: argparse.ArgumentParser):
        kwargs = dict(default=self.default, type=self.type, help=self.arg_help)

        if self.is_kwarg:
            kwargs["dest"] = self.dest
        elif self.is_vararg:
            kwargs["nargs"] = "*"
            kwargs.pop("default", "")
            if kwargs.get("type") == inspect.Parameter.empty:
                kwargs.pop("type")

        if self.type == bool or any(self.default is i for i in [True, False]):
            kwargs["action"] = "store_false" if self.default else "store_true"
            kwargs.pop("type", "")

        logger.debug(f"Attaching argument: {self.names} -> {kwargs}")
        parser.add_argument(*self.names, **kwargs)  # type: ignore

    def update_name(self, name: str):
        if name not in self.all_names:
            self.all_names.insert(0, name)
        else:
            assert self.all_names[0] == name

        self.name = name

    @property
    def names(self) -> t.Tuple[str, ...]:
        if not self.is_kwarg:
            return (self.name,)

        assert all(i.startswith("-") for i in self.all_names[1:])
        assert self.name == self.all_names[0]
        return (f"--{self.name}",) + tuple(self.all_names[1:])

    @property
    def arg_help(self) -> str:
        out = self.help or ""
        if self.default is not inspect.Parameter.empty:
            if out:
                out += ". "
            out += f"default: {self.default}"
        return out


def _get_func_params(func) -> t.List[inspect.Parameter]:
    return list(inspect.signature(func).parameters.values())


def _get_helps_from_func(func, param_names) -> t.Dict[str, str]:
    if not func.__doc__:
        return {}

    helps_from_doc = {}

    for line in dedent(func.__doc__).splitlines():
        for p in param_names:
            patt = f"  {p}:"

            if patt in line:
                helps_from_doc[p] = line.split(patt)[-1].strip()

    return helps_from_doc


class App:
    def __init__(self, *args, **kwargs):
        self.parser = argparse.ArgumentParser(*args, **kwargs)
        self.subparsers = None

    def add_arg(self, *args, **kwargs):
        self.parser.add_argument(*args, **kwargs)
        return self.parser

    add_argument = add_arg

    def main(self, fnc):
        self.parser.set_defaults(func=fnc)

        for arg in Arg.from_func(fnc):
            arg.add_to_parser(self.parser)

        if not self.parser.description:
            self.parser.description = fnc.__doc__

        @functools.wraps(fnc)
        def wrapper(*args, **kwargs):
            return fnc(*args, **kwargs)

        return wrapper

    def cmd(self, fnc) -> t.Callable:
        if not self.subparsers:
            self.subparsers = self.parser.add_subparsers()

        sub = self.subparsers.add_parser(
            fnc.__name__.replace("_", "-"), description=fnc.__doc__
        )
        logger.debug("Added subparser: %s", sub)

        for arg in Arg.from_func(fnc):
            arg.add_to_parser(sub)
            logger.debug("  Adding argument: %s", arg)

        sub.set_defaults(func=fnc)

        @functools.wraps(fnc)
        def wrapper(*args, **kwargs):
            return fnc(*args, **kwargs)

        return wrapper

    def parse_for_run(self) -> t.Tuple[t.Callable, t.Tuple[t.List, t.Dict]]:
        self.args = self.parser.parse_args()
        args = vars(self.args)
        logger.debug("Parsed args: %s", args)
        fnc = args.pop("func", None)

        if not fnc:
            self.parser.print_help()
            sys.exit(1)

        func_args = []
        func_kwargs = {}
        building_kwargs = False

        # Only pull in those parameters which `fnc` accepts, since the
        # global parser may have supplied more.
        for p in _get_func_params(fnc):
            if p.kind == inspect.Parameter.KEYWORD_ONLY:
                building_kwargs = True

            if building_kwargs:
                func_kwargs[p.name] = args[p.name]
            elif p.kind == inspect.Parameter.VAR_POSITIONAL:
                func_args.extend(args[p.name])
            else:
                func_args.append(args[p.name])

        return (fnc, (func_args, func_kwargs))

    def run(self):
        (fnc, (func_args, func_kwargs)) = self.parse_for_run()

        return fnc(*func_args, **func_kwargs)




# Copyright (C) 2007 Jan-Klaas Kollhof
# Copyright (C) 2011-2018 The python-bitcoinlib developers
# Copyright (C) 2020 James O'Beirne
#
# This section is part of python-bitcoinlib.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of the python-bitcoinlib distribution.
#
# No part of python-bitcoinlib, including this section, may be copied, modified,
# propagated, or distributed except according to the terms contained in the
# LICENSE file.

import logging
import os
import base64
import http.client as httplib
import json
import platform
import urllib.parse as urlparse
import socket
import re
import time
import http.client
import typing as t
from typing import IO, Optional as Op
from decimal import Decimal

DEFAULT_USER_AGENT = "AuthServiceProxy/0.1"
DEFAULT_HTTP_TIMEOUT = 30


logger = logging.getLogger("rpc")
logger.setLevel(logging.DEBUG)
# logger.addHandler(logging.StreamHandler())


class JSONRPCError(Exception):
    """JSON-RPC protocol error base class
    Subclasses of this class also exist for specific types of errors; the set
    of all subclasses is by no means complete.
    """

    def __init__(self, rpc_error):
        super(JSONRPCError, self).__init__(
            "msg: %r  code: %r" % (rpc_error["message"], rpc_error["code"])
        )
        self.error = rpc_error


class BaseProxy(object):
    """Base JSON-RPC proxy class. Contains only private methods; do not use
    directly."""

    def __init__(
        self,
        service_url=None,
        service_port=None,
        btc_conf_file=None,
        net_name=None,
        timeout=DEFAULT_HTTP_TIMEOUT,
        debug_stream: Op[IO] = None,
        wallet_name=None,
    ):

        self.debug_stream = debug_stream
        authpair = None
        net_name = net_name or "mainnet"
        self.timeout = timeout
        self.net_name = net_name

        # Figure out the path to the bitcoin.conf file
        if btc_conf_file is None:
            if platform.system() == "Darwin":
                btc_conf_file = os.path.expanduser(
                    "~/Library/Application Support/Bitcoin/"
                )
            elif platform.system() == "Windows":
                btc_conf_file = os.path.join(os.environ["APPDATA"], "Bitcoin")
            else:
                btc_conf_file = os.path.expanduser("~/.bitcoin")
            btc_conf_file = os.path.join(btc_conf_file, "bitcoin.conf")

        if service_url is None:
            # Bitcoin Core accepts empty rpcuser, not specified in btc_conf_file
            conf = self._get_bitcoind_conf_from_filesystem(btc_conf_file)
            if service_port is None:
                service_port = {
                    "mainnet": 8332,
                }.get(net_name, 18332)

            conf["rpcport"] = int(conf.get("rpcport", service_port))  # type: ignore
            conf["rpchost"] = conf.get("rpcconnect", "localhost")

            service_url = f"http://{conf['rpchost']}:{conf['rpcport']}"

            authpair = self._get_bitcoind_cookie_authpair(conf, btc_conf_file, net_name)
        else:
            url = urlparse.urlparse(service_url)
            authpair = "%s:%s" % (url.username or "", url.password or "")

            # Try and pull in auth information from the filesystem if it's missing.
            if authpair == ":":
                conf = self._get_bitcoind_conf_from_filesystem(btc_conf_file)
                authpair = self._get_bitcoind_cookie_authpair(
                    conf, btc_conf_file, net_name
                )
                logger.debug("pulling authpair from cookie despite intaking URL")

        if wallet_name:
            service_url = service_url.rstrip("/")
            service_url += f"/wallet/{wallet_name}"

        logger.info(f"Connecting to bitcoind: {service_url}")
        self.url = service_url

        # Credential redacted
        self.public_url = re.sub(r":[^/]+@", ":***@", self.url, 1)
        self._parsed_url = urlparse.urlparse(service_url)
        self.host = self._parsed_url.hostname

        logger.info(f"Initializing RPC client at {self.public_url}")
        # XXX keep for debugging, but don't ship:
        # logger.info(f"[REMOVE THIS] USING AUTHPAIR {authpair}")

        if self._parsed_url.scheme not in ("http",):
            raise ValueError("Unsupported URL scheme %r" % self._parsed_url.scheme)

        self.__id_count = 0

        self.__auth_header = None
        if authpair:
            self.__auth_header = b"Basic " + base64.b64encode(authpair.encode("utf8"))

    def _get_bitcoind_conf_from_filesystem(self, btc_conf_file: str) -> t.Dict:
        conf = {"rpcuser": ""}

        # Extract contents of bitcoin.conf to build service_url
        try:
            with open(btc_conf_file, "r") as fd:
                for line in fd.readlines():
                    if "#" in line:
                        line = line[: line.index("#")]
                    if "=" not in line:
                        continue
                    k, v = line.split("=", 1)
                    conf[k.strip()] = v.strip()

        # Treat a missing bitcoin.conf as though it were empty
        except FileNotFoundError:
            pass

        return conf

    def _get_bitcoind_cookie_authpair(
        self, conf: dict, btc_conf_file: str, net_name: str
    ) -> t.Optional[str]:
        """Get an authpair from the cookie or configuration files."""
        authpair = ""
        cookie_dir = conf.get("datadir", os.path.dirname(btc_conf_file))
        if net_name != "mainnet":
            cookie_dir = os.path.join(cookie_dir, net_name)
        cookie_file = os.path.join(cookie_dir, ".cookie")
        try:
            with open(cookie_file, "r") as fd:
                authpair = fd.read()
                logger.debug("read authpair from cookie")
        except (IOError, FileNotFoundError) as err:
            logger.debug("couldn't read authpair from cookie", exc_info=True)
            if "rpcpassword" in conf:
                authpair = "%s:%s" % (conf["rpcuser"], conf["rpcpassword"])
                logger.debug("read authpair from conf")
            else:
                raise ValueError(
                    "Cookie file unusable (%s) and rpcpassword not specified "
                    "in the configuration file: %r" % (err, btc_conf_file)
                )

        return authpair

    @property
    def port(self) -> int:
        if self._parsed_url.port is None:
            return httplib.HTTP_PORT
        else:
            return self._parsed_url.port

    def _getconn(self):
        return httplib.HTTPConnection(
            self._parsed_url.hostname, port=self.port, timeout=self.timeout
        )

    def _call(self, service_name, *args):
        self.__id_count += 1

        postdata = json.dumps(
            {
                "version": "1.1",
                "method": service_name,
                "params": args,
                "id": self.__id_count,
            }
        )

        logger.debug(f"[{self.public_url}] calling %s%s", service_name, args)

        headers = {
            "Host": self._parsed_url.hostname,
            "User-Agent": DEFAULT_USER_AGENT,
            "Content-type": "application/json",
        }

        if self.__auth_header is not None:
            headers["Authorization"] = self.__auth_header

        path = self._parsed_url.path
        tries = 5
        backoff = 0.3
        while tries:
            try:
                conn = self._getconn()
                conn.request("POST", path, postdata, headers)
            except (BlockingIOError, http.client.CannotSendRequest, socket.gaierror):
                logger.exception(
                    f"hit request error: {path}, {postdata}, {self._parsed_url}"
                )
                tries -= 1
                if not tries:
                    raise
                time.sleep(backoff)
                backoff *= 2
            else:
                break

        response = self._get_response(conn)
        err = response.get("error")
        if err is not None:
            if isinstance(err, dict):
                raise JSONRPCError(
                    {
                        "code": err.get("code", -345),
                        "message": err.get("message", "error message not specified"),
                    }
                )
            raise JSONRPCError({"code": -344, "message": str(err)})
        elif "result" not in response:
            raise JSONRPCError({"code": -343, "message": "missing JSON-RPC result"})
        else:
            return response["result"]

    def _get_response(self, conn):
        http_response = conn.getresponse()
        if http_response is None:
            raise JSONRPCError(
                {"code": -342, "message": "missing HTTP response from server"}
            )

        rdata = http_response.read().decode("utf8")
        try:
            loaded = json.loads(rdata, parse_float=Decimal)
            logger.debug(f"[{self.public_url}] -> {loaded}")
            return loaded
        except Exception:
            raise JSONRPCError(
                {
                    "code": -342,
                    "message": (
                        "non-JSON HTTP response with '%i %s' from server: '%.20s%s'"
                        % (
                            http_response.status,
                            http_response.reason,
                            rdata,
                            "..." if len(rdata) > 20 else "",
                        )
                    ),
                }
            )


class RawProxy(BaseProxy):
    """Low-level proxy to a bitcoin JSON-RPC service
    Unlike ``Proxy``, no conversion is done besides parsing JSON. As far as
    Python is concerned, you can call any method; ``JSONRPCError`` will be
    raised if the server does not recognize it.
    """

    def __init__(
        self,
        service_url=None,
        service_port=None,
        btc_conf_file=None,
        timeout=DEFAULT_HTTP_TIMEOUT,
        **kwargs,
    ):
        super(RawProxy, self).__init__(
            service_url=service_url,
            service_port=service_port,
            btc_conf_file=btc_conf_file,
            timeout=timeout,
            **kwargs,
        )

    def __getattr__(self, name):
        if name.startswith("__") and name.endswith("__"):
            # Prevent RPC calls for non-existing python internal attribute
            # access. If someone tries to get an internal attribute
            # of RawProxy instance, and the instance does not have this
            # attribute, we do not want the bogus RPC call to happen.
            raise AttributeError

        # Create a callable to do the actual call
        def _call_wrapper(*args):
            return self._call(name, *args)

        # Make debuggers show <function bitcoin.rpc.name> rather than <function
        # bitcoin.rpc.<lambda>>
        _call_wrapper.__name__ = name
        return _call_wrapper


BitcoinRPC = RawProxy




import hashlib
import io


# TODO: credit buidl-python

BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

MAINNET_XPRV = bytes.fromhex("0488ade4")
MAINNET_XPUB = bytes.fromhex("0488b21e")
MAINNET_YPRV = bytes.fromhex("049d7878")
MAINNET_YPUB = bytes.fromhex("049d7cb2")
MAINNET_ZPRV = bytes.fromhex("04b2430c")
MAINNET_ZPUB = bytes.fromhex("04b24746")
TESTNET_XPRV = bytes.fromhex("04358394")
TESTNET_XPUB = bytes.fromhex("043587cf")
TESTNET_YPRV = bytes.fromhex("044a4e28")
TESTNET_YPUB = bytes.fromhex("044a5262")
TESTNET_ZPRV = bytes.fromhex("045f18bc")
TESTNET_ZPUB = bytes.fromhex("045f1cf6")


def raw_decode_base58(s):
    num = 0
    # see how many leading 0's we are starting with
    prefix = b""
    for c in s:
        if num == 0 and c == "1":
            prefix += b"\x00"
        else:
            num = 58 * num + BASE58_ALPHABET.index(c)
    # put everything into base64
    byte_array = []
    while num > 0:
        byte_array.insert(0, num & 255)
        num >>= 8
    combined = prefix + bytes(byte_array)
    checksum = combined[-4:]
    if hash256(combined[:-4])[:4] != checksum:
        raise RuntimeError("bad address: {} {}".format(checksum, hash256(combined)[:4]))
    return combined[:-4]


def xpub_to_fp(xpub: str) -> str:
    raw = raw_decode_base58(xpub)

    if len(raw) != 78:
        raise ValueError("Not a proper extended key")

    version = raw[:4]

    if version not in (
        TESTNET_XPUB,
        TESTNET_YPUB,
        TESTNET_ZPUB,
        MAINNET_XPUB,
        MAINNET_YPUB,
        MAINNET_ZPUB,
    ):
        raise ValueError(f"not an xprv, yprv or zprv: {version}")

    return hash160(raw[-33:])[:4].hex()


def decode_base58(s):
    return raw_decode_base58(s)[1:]


def hash160(s):
    return hashlib.new("ripemd160", hashlib.sha256(s).digest()).digest()


def hash256(s):
    return hashlib.sha256(hashlib.sha256(s).digest()).digest()




import curses
import contextlib
import typing as t
import logging
import time
import subprocess
import sys
import threading
import datetime
from dataclasses import dataclass
from decimal import Decimal
from pathlib import Path
from collections import namedtuple
from typing import Optional as Op


logger = logging.getLogger("ui")

colr = curses.color_pair
curses_bold = curses.A_BOLD

_use_color_no_tty = True


def use_color():
    if sys.stdout.isatty():
        return True
    if _use_color_no_tty:
        return True
    return False


def esc(*codes: t.Union[int, str]) -> str:
    """Produces an ANSI escape code from a list of integers
    :rtype: text_type
    """
    return t_("\x1b[{}m").format(t_(";").join(t_(str(c)) for c in codes))


def t_(b: t.Union[bytes, t.Any]) -> str:
    """ensure text type"""
    if isinstance(b, bytes):
        return b.decode()
    return b


def b_(t: t.Union[str, t.Any]) -> bytes:
    """ensure binary type"""
    if isinstance(t, str):
        return t.encode()
    return t


def check_line(msg: str) -> str:
    return green(bold(" ✔  ")) + msg


def warning_line(msg: str) -> str:
    return red(bold(" !  ")) + msg


def info_line(msg: str) -> str:
    return bold(" □  ") + msg


def conn_line(msg: str) -> str:
    return green(bold(" ○  ")) + msg


###############################################################################
# 8 bit Color
###############################################################################


def make_color(start, end: str) -> t.Callable[[str], str]:
    def color_func(s: str) -> str:
        if not use_color():
            return s

        # render
        return start + t_(s) + end

    return color_func


# According to https://en.wikipedia.org/wiki/ANSI_escape_code#graphics ,
# 39 is reset for foreground, 49 is reset for background, 0 is reset for all
# we can use 0 for convenience, but it will make color combination behaves weird.
END = esc(0)

FG_END = esc(39)
black = make_color(esc(30), FG_END)
red = make_color(esc(31), FG_END)
green = make_color(esc(32), FG_END)
yellow = make_color(esc(33), FG_END)
blue = make_color(esc(34), FG_END)
magenta = make_color(esc(35), FG_END)
cyan = make_color(esc(36), FG_END)
white = make_color(esc(37), FG_END)
gray = make_color(esc(90), FG_END)

BG_END = esc(49)
black_bg = make_color(esc(40), BG_END)
red_bg = make_color(esc(41), BG_END)
green_bg = make_color(esc(42), BG_END)
yellow_bg = make_color(esc(43), BG_END)
blue_bg = make_color(esc(44), BG_END)
magenta_bg = make_color(esc(45), BG_END)
cyan_bg = make_color(esc(46), BG_END)
white_bg = make_color(esc(47), BG_END)

HL_END = esc(22, 27, 39)

black_hl = make_color(esc(1, 30, 7), HL_END)
red_hl = make_color(esc(1, 31, 7), HL_END)
green_hl = make_color(esc(1, 32, 7), HL_END)
yellow_hl = make_color(esc(1, 33, 7), HL_END)
blue_hl = make_color(esc(1, 34, 7), HL_END)
magenta_hl = make_color(esc(1, 35, 7), HL_END)
cyan_hl = make_color(esc(1, 36, 7), HL_END)
white_hl = make_color(esc(1, 37, 7), HL_END)

bold = make_color(esc(1), esc(22))
italic = make_color(esc(3), esc(23))
underline = make_color(esc(4), esc(24))
strike = make_color(esc(9), esc(29))
blink = make_color(esc(5), esc(25))


class Action:
    pass


class Spinner:
    def __init__(self):
        self.i = -1

    def spin(self) -> str:
        self.i += 1
        return ["◰", "◳", "◲", "◱"][self.i % 4]


class Scene:
    def set_configs(self, scr, conf, wconfs):
        self.scr = scr
        self.config = conf
        self.wallet_configs = wconfs
        self.controller = self.config.wizard_controller

    def draw(self, k: int) -> t.Tuple[int, Action]:
        pass


class MenuItem(namedtuple("MenuItem", "idx,title,action")):
    def args(self, mchoice):
        return (self.idx, self.title, mchoice == self)


class HomeScene(Scene):
    def __init__(self):
        super().__init__()

        self.setup_item = MenuItem(0, "start setup", GoSetup)
        self.dashboard_item = MenuItem(1, "dashboard", GoDashboard)
        self.send_item = MenuItem(2, "send", GoHome)
        self.recieve_item = MenuItem(3, "receive", GoHome)

        self.mitems = [
            self.setup_item,
            self.dashboard_item,
            self.send_item,
            self.recieve_item,
        ]

        self.midx = 0
        self.mchoice = self.setup_item

    def draw(self, k: int) -> t.Tuple[int, Action]:
        scr = self.scr
        curses.noecho()
        height, width = scr.getmaxyx()
        wconfigs = self.wallet_configs

        if k in [ord("q")]:
            return (-1, Quit)
        elif k in [curses.KEY_ENTER, 10, 13]:
            return (-1, self.mchoice.action)

        if k in [curses.KEY_DOWN, ord("j")] and self.midx < (len(self.mitems) - 1):
            self.midx += 1
        elif k in [curses.KEY_UP, ord("k")] and self.midx > 0:
            self.midx -= 1

        self.mchoice = self.mitems[self.midx]

        # Declaration of strings

        title: str = """
░█████╗░░█████╗░██╗░░░░░██████╗░░█████╗░░█████╗░██████╗░███████╗
██╔══██╗██╔══██╗██║░░░░░██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔════╝
██║░░╚═╝██║░░██║██║░░░░░██║░░██║██║░░╚═╝██║░░██║██████╔╝█████╗░░
██║░░██╗██║░░██║██║░░░░░██║░░██║██║░░██╗██║░░██║██╔══██╗██╔══╝░░
╚█████╔╝╚█████╔╝███████╗██████╔╝╚█████╔╝╚█████╔╝██║░░██║███████╗
░╚════╝░░╚════╝░╚══════╝╚═════╝░░╚════╝░░╚════╝░╚═╝░░╚═╝╚══════╝
    """

        title_len = len(title.splitlines()[2])
        subtitle = "your monetary glue"

        keystr = f"Wallets: {', '.join([w.name for w in wconfigs])}".format(k)[
            : width - 1
        ]

        # Centering calculations
        start_x_title = int((width // 2) - (title_len // 2) - title_len % 2)
        title_height = len(title.splitlines()) + 1

        start_y = height // 4
        title = "\n".join(
            ((" " * start_x_title) + line)[: width - start_y]
            for line in title.splitlines()
        )
        start_x_subtitle = int((width // 2) - (len(subtitle) // 2) - len(subtitle) % 2)
        start_x_keystr = int((width // 2) - (len(keystr) // 2) - len(keystr) % 2)

        with attrs(scr, colr(2), curses_bold):
            scr.addstr(start_y, width // 2, title)

        scr.addstr(start_y + title_height, start_x_subtitle, subtitle[:width])
        scr.addstr(
            start_y + title_height + 2, start_x_title, ("/ " * (title_len // 2))[:width]
        )

        if wconfigs:
            scr.addstr(start_y + title_height + 4, start_x_keystr, keystr[:width])

        def menu_option(idx: int, text: str, selected=False):
            half = width // 2

            start_str = f'{"":<6}{text:>20}{"":<6}'
            if selected:
                start_str = " -> " + start_str[4:]
            scr.addstr(start_y + title_height + 8 + idx, half, start_str[:width])

        menu_option(*self.setup_item.args(self.mchoice))
        menu_option(*self.dashboard_item.args(self.mchoice))
        menu_option(*self.send_item.args(self.mchoice))
        menu_option(*self.recieve_item.args(self.mchoice))

        scr.move(0, 0)

        # Refresh the screen
        scr.refresh()

        k = scr.getch()
        # Wait for next input
        return (k, GoHome)


class SetupScene(Scene):
    def __init__(self):
        self.bitcoin_rpc = None
        self.has_setup_coldcard = False
        self.cc_wallet: Op[t.Any] = None
        self.public_init_existed: Op[bool] = None
        self.public_contents: Op[str] = None
        self.opened_finder: Op[subprocess.Popen] = False
        self.wrote_config = False
        self.core_wallet_create = False
        self.core_imported = False
        self.core_scantxoutset = False
        self.scan_from_height = None
        self.have_rescanned = False
        self.chain_synced_info = None
        self.testaddress1 = None
        self.receive_utxo1 = None
        self.prepared_tx = None
        self.test_tx_hex = None
        self.test_tx_info = None
        self.confirm_send = False
        self.receive_utxo2 = None

        self.steps_xpos = 0
        self.steps_ypos = 0
        self.i = 0
        self.height = self.width = 0

    def new_step_line(self, msg, *attrs_, ypos: Op[int] = None) -> t.Tuple[int, int]:
        """Returns (y, x) of final cursor spot."""
        curr_ypos = ypos or self.steps_ypos
        with attrs(self.scr, *attrs_):
            self.scr.addstr(curr_ypos, self.steps_xpos, msg[: self.width])

        if ypos is None:
            self.steps_ypos += 1

        if self.steps_ypos >= (self.height - 2):
            # Scroll to make room
            self.scr.scrollok(True)
            self.scr.scroll((self.steps_ypos - self.height) + 2)

        return (curr_ypos, len(msg) + self.steps_xpos)

    def new_sec(self):
        self.steps_ypos += 1

    def draw(self, k: int) -> t.Tuple[int, Action]:
        scr = self.scr
        self.height, self.width = scr.getmaxyx()
        self.steps_ypos = 7

        self.i += 1
        if self.i % 1000 == 0:
            self.i = 0

        scr.timeout(400)

        title = f"""
              __
.-----.-----.|  |_.--.--.-----.
|__ --|  -__||   _|  |  |  _  |
|_____|_____||____|_____|   __| {'=' * (self.width - 39)}
                        |__|
"""
        y_start = 0
        x_start = 4
        self.steps_xpos = x_start + 4
        check_xpos = self.steps_xpos - 3

        title = "\n".join(
            ((" " * x_start) + line)[: (self.width - y_start)]
            for line in title.splitlines()
        )

        with attrs(scr, colr(2), curses_bold):
            scr.addstr(y_start, x_start, title)

        def wait():
            """Return this when we're waiting on a step."""
            scr.refresh()
            return (scr.getch(), GoSetup)

        def delay_for_effect():
            scr.refresh()
            time.sleep(0.6)

        (core_ypos, _) = self.new_step_line("Searching for Bitcoin Core... ")
        box(scr, core_ypos, check_xpos)

        if not self.bitcoin_rpc:
            rpc = None
            try:
                self.bitcoin_rpc = self.controller.discover_rpc(self.config)

                if not self.bitcoin_rpc:
                    raise ValueError("no rpc found")

                delay_for_effect()
            except Exception:
                logger.exception("RPC failed")
                url = getattr(rpc, "url", "???")
                self.new_step_line(
                    f"Can't connect to Bitcoin Core (trying {url})", colr(2)
                )
                self.new_step_line(
                    "Try starting Bitcoin Core or editing your config at "
                    f"{self.config.loaded_from}",
                    colr(6),
                )
                return wait()

        testnet_str = " [testnet]" if self.bitcoin_rpc.net_name == "testnet" else ""
        self.new_step_line(
            f"Found it! ({self.bitcoin_rpc.public_url}){testnet_str}", colr(6)
        )
        green_check(scr, core_ypos, check_xpos)

        self.new_sec()
        (cc_ypos, cc_xpos) = self.new_step_line("Have you set up your coldcard? [Y/n] ")
        box(scr, cc_ypos, check_xpos)

        self.new_step_line("See: https://coldcardwallet.com/docs/quick", colr(4))

        if not self.has_setup_coldcard:
            if key_y(k):
                self.has_setup_coldcard = True
            else:
                scr.move(cc_ypos, cc_xpos)
                return wait()

        green_check(scr, cc_ypos, check_xpos)

        self.new_sec()
        (chain_ypos, chain_xpos) = self.new_step_line("Waiting for chain to sync...")
        box(scr, chain_ypos, check_xpos)

        if not self.chain_synced_info:
            # Really just for effect.
            delay_for_effect()

            chaininfo = self.bitcoin_rpc.getblockchaininfo()
            progress = chaininfo["verificationprogress"]

            if progress < 0.999:
                (chain_ypos, chain_xpos) = self.new_step_line(
                    f"Initial block download progress: {progress * 100:.2f}%"
                )
                scr.timeout(4000)
                return wait()
            else:
                self.chain_synced_info = chaininfo

        scr.timeout(400)
        self.new_step_line(
            f"Chain synced to height {self.chain_synced_info['blocks']}", colr(6)
        )
        green_check(scr, chain_ypos, check_xpos)

        self.new_sec()
        (pub_y, _) = self.new_step_line(
            "Export your Coldcard's public.txt and put it in this directory"
        )
        # TODO add spinner
        box(scr, pub_y, check_xpos)

        self.new_step_line(
            "See: https://coldcardwallet.com/docs/microsd#dump-summary-file",
            colr(4),
        )

        public = Path("./public.txt")
        if self.public_init_existed is None:
            self.public_init_existed = public.exists()

        if self.public_contents is None:
            delay_for_effect()
            if not self.public_init_existed:
                self.new_step_line(
                    "Here, I'll open a file explorer for you. Drop it in there.",
                    colr(4),
                )

                if not self.opened_finder:
                    self.opened_finder = subprocess.Popen(
                        "sleep 2; xdg-open .", shell=True
                    )

            if public.exists() and self.cc_wallet is None:
                self.public_contents = public.read_text()
                try:
                    self.cc_wallet = self.controller.parse_cc_public(
                        self.public_contents,
                        self.bitcoin_rpc,
                    )
                except Exception:
                    logger.exception("Failed to parse public.txt contents")
                    self.cc_wallet = ""
                    return wait()
            else:
                return wait()
        elif not self.cc_wallet:
            self.new_step_line(
                "Failed to extract wallet info from your public.txt!",
                colr(2),
            )
            self.new_step_line(
                "Check coldcore.log.",
                colr(2),
            )
            return wait()

        self.cc_wallet.bitcoind_json_url = self.bitcoin_rpc.url

        self.new_step_line("Parsed xpub as", colr(6))
        self.new_step_line(f"  {self.cc_wallet.descriptor_base}", colr(6))

        if not self.wrote_config:
            self.config.add_new_wallet(self.cc_wallet)
            self.config.write()
            self.wrote_config = True

        self.new_step_line(f"Wrote config to {self.config.loaded_from}")
        green_check(scr, pub_y, check_xpos)

        scr.refresh()

        self.new_sec()
        (core_y, _) = self.new_step_line("Setting up wallet in core")
        box(scr, core_y, check_xpos)

        rpc = self.bitcoin_rpc

        if not self.core_wallet_create:
            self.controller.rpc_wallet_create(rpc, self.cc_wallet)
            self.core_wallet_create = True

        # Long timeout for scanning.

        self.new_step_line(
            f"Created wallet {self.cc_wallet.name} in Core as watch-only", colr(6)
        )

        scr.refresh()

        if not self.core_imported:
            rpcw = self.config.rpc(self.cc_wallet, timeout=6000)
            rpcw.importmulti(*self.cc_wallet.importmulti_args())
            self.core_imported = True

        self.new_step_line("Imported descriptors 0/* and 1/* (change)", colr(6))
        (scan_y, scan_x) = self.new_step_line(
            "Scanning the UTXO set... (may take a few minutes)", colr(0)
        )

        scr.refresh()

        if not self.core_scantxoutset:
            rpcw = self.config.rpc(self.cc_wallet, timeout=6000)
            self.core_scantxoutset = rpcw.scantxoutset(
                *self.cc_wallet.scantxoutset_args()
            )

        unspents = self.core_scantxoutset["unspents"]
        if self.core_scantxoutset["unspents"]:
            bal = sum([i["amount"] for i in unspents])
            self.scan_from_height = min([i["height"] for i in unspents])
            self.new_step_line(
                f"Found a balance of {bal} BTC, earliest height: "
                f"{self.scan_from_height}",
                colr(5),
                curses_bold,
                ypos=scan_y,
            )
        else:
            self.new_step_line(
                "Couldn't find a balance - new wallet eh?",
                colr(1),
                ypos=scan_y,
            )
        green_check(scr, core_y, check_xpos)

        scr.refresh()

        if self.scan_from_height:
            self.new_sec()
            (scanbc_y, _) = self.new_step_line(
                f"Scanning the chain history since block {self.scan_from_height}. "
                "I'd get a coffee tbh.",
                colr(0),
            )
            self.new_step_line(
                "This helps us index transactions associated with your coins.",
                colr(4),
            )

            scr.refresh()

            if not self.have_rescanned:
                rpcw = self.config.rpc(self.cc_wallet, timeout=0)
                box(scr, scanbc_y, check_xpos)
                scr.refresh()
                rpcw.rescanblockchain(self.scan_from_height)
                self.have_rescanned = True

            self.new_step_line("Scan complete", colr(6))
            green_check(scr, scanbc_y, check_xpos)

        self.new_sec()
        (testy, _) = self.new_step_line(
            "OK, now let's test your wallet by receiving a test transaction."
        )
        box(scr, testy, check_xpos)

        if not self.testaddress1:
            rpcw = self.config.rpc(self.cc_wallet)
            self.testaddress1 = rpcw.getnewaddress()

        self.new_step_line("Send a tiny test amount to")
        self.new_step_line("")
        self.new_step_line(f"    {self.testaddress1}", colr(2), curses_bold)
        self.new_step_line("")
        (waity, waitx) = self.new_step_line(
            "Waiting for transaction", colr(4), curses_bold
        )

        if not self.receive_utxo1:
            scr.addstr(waity, waitx + 1, self._get_scroller())

            scr.timeout(2000)
            rpcw = self.config.rpc(self.cc_wallet)
            utxos = self.controller.get_utxos(rpcw)
            self.receive_utxo1 = utxos.get(self.testaddress1)

            if not self.receive_utxo1:
                return wait()

        self.new_step_line(
            f"Received amount of {self.receive_utxo1.amount} "
            f"({self.receive_utxo1.txid[:8]})",
            colr(5),
            curses_bold,
            ypos=waity,
        )
        green_check(scr, testy, check_xpos)

        self.new_sec()
        (testy, _) = self.new_step_line("Now let's test your sending capabilities.")

        if not self.prepared_tx:
            rpcw = self.config.rpc(self.cc_wallet)
            self.toaddress1 = rpcw.getnewaddress()

            # Send 90% of the value over.
            # TODO this is only for testing and is potentially dangerous
            send_amt = str((self.receive_utxo1.amount * 9) / 10)
            self.prepared_tx = self.controller.prepare_send(
                self.config,
                rpcw,
                self.toaddress1,
                send_amt,
                [self.receive_utxo1.address],
            )

        self.new_step_line(
            f"You're going to send to another address you own, {self.toaddress1}."
        )
        self.new_step_line(f"I've prepared a transaction called '{self.prepared_tx}'")
        box(scr, testy, check_xpos)

        self.new_step_line(
            "Here, I'll open a file explorer for you.",
            colr(4),
        )

        self.new_step_line(
            "Transfer it to your coldcard via microSD from there.",
            colr(4),
        )

        if not self.opened_finder:
            self.opened_finder = subprocess.Popen("sleep 2; xdg-open .", shell=True)

        # TODO: coldcard specific?
        signed_filename = self.prepared_tx.replace(".psbt", "-signed.psbt")

        (wait2y, wait2x) = self.new_step_line(
            f"Waiting for the signed file ({signed_filename})", colr(4), curses_bold
        )

        filepath = Path(signed_filename)
        if not filepath.exists():
            scr.addstr(wait2y, wait2x + 1, self._get_scroller())
            return wait()
        else:
            rpcw = self.config.rpc(self.cc_wallet)
            self.test_tx_hex = self.controller.psbt_to_tx_hex(rpcw, filepath)

        self.new_step_line("Cool, got the signed PSBT!", colr(6), curses_bold)

        if not self.test_tx_info:
            rpcw = self.config.rpc(self.cc_wallet)
            self.test_tx_info = _get_tx_info(rpcw, self.test_tx_hex)

        assert len(self.test_tx_info) == 2
        self.new_step_line(f"  {self.test_tx_info[0]}", colr(0), curses_bold)
        self.new_step_line("Confirm send? [y/n]", colr(2), curses_bold)

        if not self.confirm_send:
            if key_y(k):
                self.confirm_send = True
                rpcw.sendrawtransaction(self.test_tx_hex)
            else:
                return wait()

        self.new_step_line("Transaction broadcast!", colr(2), curses_bold)
        (waity2, waitx2) = self.new_step_line(
            "Waiting for transaction", colr(4), curses_bold
        )

        if not self.receive_utxo2:
            scr.addstr(waity2, waitx2 + 1, self._get_scroller())

            scr.timeout(1000)
            rpcw = self.config.rpc(self.cc_wallet)
            utxos = self.controller.get_utxos(rpcw)
            self.receive_utxo2 = utxos.get(self.toaddress1)

            if not self.receive_utxo2:
                return wait()

        self.new_step_line(
            f"Received amount of {self.receive_utxo2.amount} "
            f"({self.receive_utxo2.txid[:8]})",
            colr(5),
            curses_bold,
            ypos=waity,
        )
        green_check(scr, testy, check_xpos)

        self.new_step_line(
            "Your wallet is good to go! Press q to exit.", colr(5), curses_bold
        )

        scr.move(self.height - 1, self.width - 1)
        # Refresh the screen
        scr.refresh()

        k = scr.getch()
        # Wait for next input
        return (k, GoSetup)

    def _get_scroller(self, do_spin=True):
        if not do_spin:
            return "   "
        modi = self.i % 3
        return {
            0: "[.  ]",
            1: "[ . ]",
            2: "[  .]",
        }[modi]


def _get_tx_info(rpcw, hex_val: str) -> t.List[str]:
    """Return a list of strings detailing the actions of a tx."""
    info = rpcw.decoderawtransaction(hex_val)
    outs: t.List[t.Tuple[str, Decimal]] = []
    out_strs = []

    for out in info["vout"]:
        addrs = ",".join(out["scriptPubKey"]["addresses"])
        outs.append((addrs, out["value"]))

        for o in outs:
            try:
                addr_info = rpcw.getaddressinfo(o[0])
            except Exception:
                # TODO handle this
                raise

            yours = addr_info["ismine"] or addr_info["iswatchonly"]
            yours_str = "  (your address)" if yours else ""
            out_strs.append(f"-> {o[0]}  ({o[1]} BTC){yours_str}")

    return out_strs


def draw_onboard(k: int) -> Action:
    return Quit


def green_check(scr, y, x):
    with attrs(scr, colr(5), curses_bold):
        scr.addstr(y, x, "✔")


def box(scr, y, x):
    with attrs(scr, colr(2), curses_bold):
        scr.addstr(y, x, "□")


def key_y(k: int):
    return k in {ord("y"), ord("Y"), 10, 13, curses.KEY_ENTER}


def _s(window, y, x, msg, attr=0):
    """A width-safe version of addstr."""
    (_, width) = window.getmaxyx()
    window.addstr(y, x, msg[:width], attr)


class DashboardScene(Scene):
    def __init__(self):
        self.utxos = {}
        self.threads = []
        self.threads_started = False
        self.new_addrs = []
        self.blocks = []

        self.conn_status = None
        self.loop_count = 0

    def start_threads(self):
        if self.threads_started:
            return

        wall = self.wallet_configs[0]
        t1 = threading.Thread(
            target=_get_utxo_lines,
            args=(self.config.rpc(wall), self.controller, self.utxos),
        )
        t1.start()
        self.threads.append(t1)

        t2 = threading.Thread(
            target=_get_new_blocks,
            args=(self.config.rpc(), self.blocks),
        )
        t2.start()
        self.threads.append(t2)

        self.threads_started = True
        self.rpc = self.config.rpc()

    def stop_threads(self):
        stop_threads_event.set()
        for thread in self.threads:
            thread.join()

    def draw(self, k: int) -> t.Tuple[int, Action]:
        try:
            return self._draw(k)
        except Exception:
            logger.exception("Dashboard curses barfed")
            self.stop_threads()
            raise

        return (ord("q"), GoHome)

    def _draw(self, k: int) -> t.Tuple[int, Action]:
        scr = self.scr
        self.height, self.width = scr.getmaxyx()
        wall = self.wallet_configs[0]

        substartx = 3
        substarty = 2
        sub_height = int(self.height * 0.45)

        balwidth = max(int(self.width * 0.5), 61)
        addrwidth = max(int(self.width * 0.4), 24)

        self.start_threads()

        self.balance_win = scr.derwin(sub_height, balwidth, substarty, substartx)
        self.balance_win.border()
        _s(self.balance_win, 0, 2, " UTXOs ")

        _s(
            self.balance_win,
            2,
            2,
            f"{'address':<44}{'confs':>10}{'BTC':>12}",
        )

        with utxos_lock:
            starty = 2
            startx = 2
            max_lines = sub_height - 2

            _s(self.balance_win, starty, startx, "")
            starty += 1

            if max_lines < len(self.utxos):
                _s(
                    self.balance_win,
                    starty,
                    startx,
                    "-- too many UTXOs to fit --",
                    curses.A_BOLD,
                )
                starty += 1

            sorted_utxos = sorted(self.utxos.values(), key=lambda u: -u.num_confs)[
                -max_lines:
            ]
            total_bal = f"{sum([u.amount for u in sorted_utxos])}"
            i = 0

            for u in sorted_utxos:
                line = f"{u.address:<44}{u.num_confs:>10}{u.amount:>12}"
                attrslist = []

                if u.num_confs < 6:
                    attrslist.extend([colr(3), curses_bold])

                with attrs(self.balance_win, *attrslist):
                    _s(self.balance_win, starty + i, startx, line)

                i += 1

            _s(
                self.balance_win,
                starty + i + 1,
                startx,
                f"{' ':<54}{total_bal:>12}",
                curses.A_BOLD,
            )

        if k == ord("n"):
            if len(self.new_addrs) < 10:
                rpcw = self.config.rpc(wall)
                self.new_addrs.append(rpcw.getnewaddress())

        self.address_win = scr.derwin(
            sub_height, addrwidth, substarty, substartx + balwidth + 1
        )
        self.address_win.box()
        _s(self.address_win, 0, 2, " addresses ")
        _s(self.address_win, 2, 2, "press 'n' to get new address", curses.A_ITALIC)

        with utxos_lock:
            utxo_addrs = {u.address for u in self.utxos.values()}
            # Strip out used addresses.
            self.new_addrs = [a for a in self.new_addrs if a not in utxo_addrs]

            for i, addr in enumerate(self.new_addrs):
                _s(self.address_win, 3 + i, 2, addr)

        chainwin_height = int(self.height * 0.25)
        chainwin_width = int(self.width * 0.9)

        self.chain_win = scr.derwin(
            chainwin_height, chainwin_width, substarty + sub_height, substartx
        )
        self.chain_win.box()
        _s(self.chain_win, 0, 2, " chain status ")

        max_history = chainwin_height - 4

        if not self.conn_status or self.loop_count % 20 == 0:
            try:
                rpc = self.config.rpc()
                netinfo = self.rpc.getnetworkinfo()
            except Exception:
                self.conn_status = warning_line("! couldn't connect to Bitcoin Core")
            else:
                ver = netinfo["subversion"].strip("/")
                self.conn_status = (
                    f"✔ connected to version {ver} at {rpc.host}:{rpc.port}"
                )

        _s(self.chain_win, 2, 3, self.conn_status)

        with blocks_lock:
            for i, b in enumerate(self.blocks[-max_history:]):
                blockstr = (
                    f"{b.time_saw} | block {b.height} (...{b.hash[-8:]}) - "
                    f"{b.median_fee} sat/B - "
                    f"{b.txs} txs - "
                    f"subsidy: {b.subsidy / 100_000_000}"
                )
                _s(self.chain_win, 4 + i, 3, blockstr[:chainwin_width])

        scr.refresh()

        # scr.move(self.width, self.height)

        scr.timeout(400)
        next_k = scr.getch()
        self.loop_count += 1

        if next_k == ord("q"):
            self.stop_threads()

        return (next_k, GoDashboard)


@dataclass
class Block:
    hash: str
    height: int
    time_saw: datetime.datetime
    median_fee: float
    subsidy: float
    txs: int


stop_threads_event = threading.Event()
utxos_lock = threading.Lock()
blocks_lock = threading.Lock()


def _get_new_blocks(rpc, blocks):
    last_saw = None

    while True:
        saw = rpc.getbestblockhash()

        if saw != last_saw:
            stats = rpc.getblockstats(saw)
            with blocks_lock:
                blocks.append(
                    Block(
                        saw,
                        stats["height"],
                        datetime.datetime.now(),
                        stats["feerate_percentiles"][2],
                        stats["subsidy"],
                        stats["txs"],
                    )
                )
            last_saw = saw

        time.sleep(1)

        if stop_threads_event.is_set():
            return


def _get_utxo_lines(rpcw, controller, utxos):
    """
    Poll constantly for new UTXOs.
    """
    while True:
        new_utxos = controller.get_utxos(rpcw)

        with utxos_lock:
            utxos.clear()
            utxos.update(new_utxos)

        time.sleep(1)

        if stop_threads_event.is_set():
            return


GoHome = Action()
GoSetup = Action()
GoDashboard = Action()
Quit = Action()


def draw_menu(scr, config, wallet_configs):
    # Clear and refresh the screen for a blank canvas
    scr.clear()
    scr.refresh()
    scr.scrollok(True)

    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_YELLOW, curses.COLOR_BLACK)

    home = HomeScene()
    home.set_configs(scr, config, wallet_configs)

    setup = SetupScene()
    setup.set_configs(scr, config, wallet_configs)

    dashboard = DashboardScene()
    dashboard.set_configs(scr, config, wallet_configs)

    action = GoHome
    k = 0

    while action != Quit:
        # Initialization
        scr.clear()
        height, width = scr.getmaxyx()

        # FIXME

        try:
            kstr = curses.keyname(k).decode()
        except ValueError:
            kstr = "???"

        statusbarstr = f"Press 'q' to exit | never sell | last keypress: {kstr} ({k})"
        if k == -1:
            statusbarstr += " | waiting"
        # Render status bar
        with attrs(scr, colr(3)):
            try:
                scr.addstr(height - 1, 0, statusbarstr[:width])
                scr.addstr(
                    height - 1,
                    len(statusbarstr),
                    (" " * (width - len(statusbarstr) - 1))[:width],
                )
                # TODO
            except Exception:
                pass

        if action == GoHome:
            (k, action) = home.draw(k)
        elif action == GoSetup:
            (k, action) = setup.draw(k)
        elif action == GoDashboard:
            (k, action) = dashboard.draw(k)

        if k == ord("q") or action == Quit:
            break


@contextlib.contextmanager
def attrs(scr, *attrs):
    for a in attrs:
        scr.attron(a)
    yield
    for a in attrs:
        scr.attroff(a)


def _pad_str(s: str, num: int) -> str:
    return (" " * num) + s + (" " * num)


def start_ui(config, wallet_configs):
    curses.wrapper(draw_menu, config, wallet_configs)


    start_ui,
    Spinner,
    check_line,
    warning_line,
    info_line,
    yellow,
    bold,
    conn_line,
)

__VERSION__ = "0.1.0-alpha"

root_logger = logging.getLogger()
logger = logging.getLogger("main")

BitcoinRPC = RawProxy

MAINNET = "mainnet"
TESTNET = "testnet3"


cli = App()
cli.add_arg("--verbose", "-v", action="store_true", default=False)
cli.add_arg(
    "--config",
    "-c",
    action="store",
    default=None,
    help=(
        "Path to config file. Can be a `pass:Path/To/Config` or "
        "a filename ending in .gpg."
    ),
)
cli.add_arg("--debug", "-d", action="store_true", default=False)
cli.add_arg(
    "--testnet",
    action="store_true",
    default=False,
    help="Try to connect on the testnet network initially instead of mainnet.",
)
cli.add_arg(
    "--version",
    action="version",
    version=f"coldcore {__VERSION__}",
)
cli.add_arg(
    "--wallet",
    "-w",
    action="store",
    default=None,
    help="The specific wallet to open.",
)

PASS_PREFIX = "pass:"


def _err(s: str):
    print(s, file=sys.stderr, flush=True)


def _warn(s: str):
    print(warning_line(s), file=sys.stderr, flush=True)


def setup_logging() -> Op[Path]:
    """
    Configure logging; only log when --debug is enabled to prevent unintentional
    data leaks.

    Returns a path to the logfile if one is being used.
    """
    # TODO base this on config?
    log_path = "coldcore.log"
    formatter = logging.Formatter("%(asctime)s [%(name)s] %(levelname)s - %(message)s")
    log_filehandler = logging.FileHandler(log_path)
    log_filehandler.setLevel(logging.DEBUG)
    log_filehandler.setFormatter(formatter)

    if cli.args.debug:
        root_logger.setLevel(logging.DEBUG)
        root_logger.addHandler(log_filehandler)
        logger.setLevel(logging.DEBUG)
        return Path(log_path)

    return None


@dataclass
class Wallet:
    """
    In-memory representation of a single BIP32 HD wallet. Often but not necessarily
    backed by a hardware wallet.
    """

    fingerprint: str
    deriv_path: str
    xpub: str

    # The name of the watch-only wallet stored in Bitcoin Core.
    bitcoind_name: str

    # TODO at some point we'll support non-WPKH descriptors.
    descriptors: t.List["WpkhDescriptor"] = field(default_factory=list)

    earliest_block: Op[int] = None
    bitcoind_json_url: Op[str] = None

    # If given, this was loaded from an external storage mechanism (e.g. pass, gpg).
    # Respect this when translating back to INI.
    loaded_from: Op[str] = None

    @property
    def name(self):
        """
        The coldcore name of the wallet; not necessarily the name of what is
        stored in bitcoind.
        """
        raise NotImplementedError

    @property
    def descriptor_base(self):
        return f"wpkh([{self.fingerprint}{self.deriv_path}]{self.xpub})"

    @property
    def net_name(self):
        if self.xpub.startswith("tpub"):
            return TESTNET
        elif self.xpub.startswith("xpub"):
            return MAINNET
        else:
            raise ValueError("unhandled xpub prefix")

    def scantxoutset_args(self) -> t.Tuple[str, t.List[str]]:
        return ("start", [d.with_checksum for d in self.descriptors])

    def importmulti_args(self) -> t.Tuple:
        # TODO: use scantxoutset to take a guess at the earliest we need to do a
        # full rescan.
        args = [
            {
                "desc": d.with_checksum,
                "internal": d.is_change,
                # TODO be more decisive about this gap limit. Right now it's sort of
                # arbitrary.
                "range": [0, 3000],
                # TODO be smarter about this
                # TODO timestamp seems to be disregarded in core?
                "timestamp": "now",
                "keypool": True,
                "watchonly": True,
            }
            for d in self.descriptors
        ]

        return (args,)

    @property
    def as_ini_dict(self) -> t.Dict:
        if self.loaded_from:
            # TODO it's incumbent upon the user to maintain this themmselves?
            return {"load_from": self.loaded_from}

        checksums = {}
        for d in self.descriptors:
            checksums.update(d.change_to_checksum)

        return {
            "fingerprint": self.fingerprint,
            "deriv_path": self.deriv_path,
            "xpub": self.xpub,
            "bitcoind_name": self.bitcoind_name,
            "bitcoind_json_url": self.bitcoind_json_url or "",
            "earliest_block": str(self.earliest_block or ""),
            "checksum_map": json.dumps(checksums),
        }

    @property
    def loaded_xpub(self):
        if not hasattr(self, "__loaded_xpub"):
            self.__loaded_xpub = self.__loaded_xpub.strip()
        return self.__loaded_xpub

    @classmethod
    def from_ini(cls, name: str, rpc: BitcoinRPC, conf: ConfigParser) -> "Wallet":
        this_conf = conf[name]
        load_from = this_conf.get("load_from")

        if load_from:
            content: Op[str] = ""
            if _is_pass_path(load_from):
                passpath = load_from.split(PASS_PREFIX, 1)[-1]
                content = Pass().read(passpath, action=f"Requesting wallet {name})")
            elif load_from.endswith(".gpg"):
                content = GPG().read(load_from)  # type: ignore
            else:
                raise ValueError(f"from directive unrecognized: {load_from}")

            if not content:
                raise ValueError(f"failed to retrieve config from {load_from}")

            conf2 = ConfigParser()
            try:
                conf2.read_string(content)
            except Exception:
                msg = f"Failed to read config for wallet {name} ({load_from})"
                logger.exception(msg)
                _err(msg)
                sys.exit(1)

            this_conf = conf2[name]

        fp = this_conf["fingerprint"]
        deriv_path = this_conf["deriv_path"]
        bitcoind_name = this_conf["bitcoind_name"]
        xpub = this_conf["xpub"]
        checksum_map = json.loads(this_conf["checksum_map"])
        url = this_conf.get("bitcoind_json_url")
        earliest_block = (
            int(this_conf.get("earliest_block") or 0) or None
        )  # type: ignore

        if set(checksum_map.keys()) != {"1", "0"}:
            raise ValueError(f"unexpected checksum map contents: {checksum_map}")

        descs = [
            WpkhDescriptor.from_conf(
                fp,
                deriv_path,
                xpub,
                is_change=is_change,
                checksum=checksum_map["1" if is_change else "0"],
            )
            for is_change in [False, True]
        ]

        return cls(
            fp,
            deriv_path,
            xpub,
            bitcoind_name,
            descs,
            earliest_block,
            url,
            loaded_from=load_from,
        )


class CCWallet(Wallet):
    """
    A wallet whose private key lives on a Coldcard device.
    """

    @property
    def name(self):
        return f"coldcard-{self.fingerprint.lower()}"

    @classmethod
    def from_io(
        cls, inp: t.IO, rpc: BitcoinRPC, earliest_block: Op[int] = None
    ) -> "CCWallet":
        """
        Instantiate a CCWallet from the public output generated by the
        coldcard.
        """
        # TODO test the shit out of this

        content = inp.read()
        as_lines = content.splitlines()
        xpub_prefix = "xpub"

        if re.search(r" => tpub", content):
            xpub_prefix = "tpub"

        masterpubkey = ""
        for idx, line in enumerate(as_lines):
            if "'master' extended public key" in line:
                masterpubkey = as_lines[idx + 2].strip()

        if not masterpubkey.startswith(xpub_prefix):
            raise ValueError("file format unexpected: master key")

        # We don't do anything with the masterpubkey other than compute a
        # fingerprint based on it.
        fp = xpub_to_fp(masterpubkey).lower()
        del masterpubkey

        m = re.search(r"master key fingerprint: (?P<fp>[a-zA-Z0-9]+)", content)

        # Optionally verify the master key fingerprint with a second source.
        if m:
            fp2 = m.groupdict()["fp"].lower()

            if fp2 != fp:
                raise ValueError(f"fingerprints don't match: {fp} vs. {fp2}")

        m2 = re.search(
            f"m/84'(?P<deriv_suffix>\\S+) => {xpub_prefix}(?P<xpub>[a-zA-Z0-9]+)",
            content,
        )

        if not m2:
            raise ValueError("couldn't find xpub path")

        deriv_path = "/84h"
        suffix = m2.groupdict()["deriv_suffix"]

        if not re.fullmatch(r"(/\d+'?)+", suffix):
            raise ValueError(f"derivation path not expected: {suffix}")

        deriv_path += suffix.replace("'", "h")

        if not re.search(deriv_path.replace("h", "'") + f" => {xpub_prefix}", content):
            raise ValueError(f"inferred derivation path appears invalid: {deriv_path}")

        xpub: str = xpub_prefix + m2.groupdict()["xpub"]

        def desc_to_checksum(desc: WpkhDescriptor) -> str:
            try:
                return rpc.getdescriptorinfo(desc.base)["checksum"]
            except JSONRPCError:
                # TODO handle
                raise

        descs = []
        for is_change in [False, True]:
            desc = WpkhDescriptor.from_conf(
                fp, deriv_path, xpub, is_change=is_change, checksum=""
            )
            desc.checksum = desc_to_checksum(desc)
            descs.append(desc)

        return cls(
            fp,
            deriv_path,
            xpub,
            f"coldcard-{fp.lower()}",
            descriptors=descs,
            earliest_block=earliest_block,
        )


@dataclass
class WpkhDescriptor:
    # The descriptor without the checksum.
    base: str
    checksum: str
    # Does this descriptor correspond to a change wallet?
    is_change: bool

    @property
    def with_checksum(self):
        return f"{self.base}#{self.checksum}"

    @property
    def change_to_checksum(self):
        key = "1" if self.is_change else "0"
        return {key: self.checksum}

    @classmethod
    def from_conf(
        cls,
        fingerprint: str,
        deriv_path: str,
        xpub: str,
        is_change: bool,
        checksum: str,
    ) -> "WpkhDescriptor":
        change = 1 if is_change else 0
        base = f"wpkh([{fingerprint.lower()}{deriv_path}]{xpub}/{change}/*)"
        return cls(base, checksum, is_change)


@dataclass
class UTXO:
    address: str
    amount: Decimal
    num_confs: int
    txid: str
    vout: int

    @classmethod
    def from_listunspent(cls, rpc_outs: t.List[t.Dict]) -> t.List["UTXO"]:
        return [
            cls(
                out["address"],
                out["amount"],
                out["confirmations"],
                out["txid"],
                out["vout"],
            )
            for out in rpc_outs
        ]


class WizardController:
    """Used to proxy logic into the terminal UI."""

    def create_config(self) -> "GlobalConfig":
        return _get_config()[0]

    def parse_cc_public(self, contents: str, rpc: BitcoinRPC) -> CCWallet:
        return CCWallet.from_io(io.StringIO(contents), rpc)

    def rpc_wallet_create(self, *args, **kwargs):
        return rpc_wallet_create(*args, **kwargs)

    def discover_rpc(self, *args, **kwargs) -> Op[BitcoinRPC]:
        return discover_rpc(*args, **kwargs)

    def get_utxos(self, rpcw):
        return get_utxos(rpcw)

    def prepare_send(self, *args, **kwargs) -> str:
        return _prepare_send(*args, **kwargs)

    def psbt_to_tx_hex(self, *args, **kwargs) -> str:
        return _psbt_to_tx_hex(*args, **kwargs)


def discover_rpc(
    config: Op["GlobalConfig"] = None, url: Op[str] = None
) -> Op[BitcoinRPC]:
    """Return an RPC connection to Bitcoin if possible."""
    service_url = None
    if config:
        service_url = config.bitcoind_json_url
    elif url:
        service_url = url

    for i in (MAINNET, TESTNET):
        try:
            logger.info(f"trying RPC for {i} at {service_url}")
            rpc = get_rpc(service_url, net_name=i)
            rpc.help()
            logger.info(f"found RPC connection at {rpc.url}")
        except Exception:
            logger.debug("couldn't connect to Core RPC", exc_info=True)
        else:
            return rpc
    return None


def get_rpc(
    url: Op[str] = None,
    wallet: Op[Wallet] = None,
    quiet: bool = False,
    **kwargs,
) -> BitcoinRPC:
    """
    Get a connection to some Bitcoin JSON RPC server. Handles connection caching.

    If connecting to a wallet, ensure the wallet is loaded.
    """
    if not hasattr(get_rpc, "_rpc_cache"):
        setattr(get_rpc, "_rpc_cache", {})
    cache = get_rpc._rpc_cache  # type: ignore

    wallet_name = wallet.name if wallet else ""

    if wallet_name in cache:
        return cache[wallet_name]

    if not wallet:
        got = _get_rpc_inner(url, **kwargs)
        cache[wallet_name] = got
        if not quiet:
            hoststr = yellow(f"{got.host}:{got.port}")
            _err(conn_line(f"connected to Bitcoin Core at {hoststr}"))
    else:
        plain_rpc = _get_rpc_inner(url, net_name=wallet.net_name, **kwargs)
        try:
            # We have to ensure the wallet is loaded before accessing its
            # RPC.
            plain_rpc.loadwallet(wallet.name)
        except JSONRPCError as e:
            # Wallet already loaded.
            if e.error.get("code") != -4:  # type: ignore
                raise
        cache[wallet_name] = _get_rpc_inner(
            url, net_name=wallet.net_name, wallet_name=wallet.name, **kwargs
        )

    return cache[wallet_name]


def _get_rpc_inner(
    url: Op[str] = None, timeout: int = (60 * 5), **kwargs
) -> BitcoinRPC:
    return BitcoinRPC(
        url,
        timeout=timeout,
        debug_stream=(sys.stderr if cli.args.debug else None),
        **kwargs,
    )


@dataclass
class GlobalConfig:
    """Coldcore-specific configuration."""

    loaded_from: str
    raw_config: ConfigParser
    bitcoind_json_url: Op[str] = None
    default_wallet: Op[str] = None
    stdout: t.IO = sys.stdout
    stderr: t.IO = sys.stderr
    wizard_controller: WizardController = WizardController()

    disable_echo: bool = False

    # If true, skip anything that would block on user input.
    no_interaction: bool = False

    # Which GPG key should we encrypt with?
    # See: gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html
    gpg_default_key: Op[str] = os.environ.get("COLDCORE_GPG_KEY")

    def rpc(self, wallet: Op[Wallet] = None, **kwargs) -> BitcoinRPC:
        return get_rpc(self.bitcoind_json_url, wallet, **kwargs)

    def info(self, *args, **kwargs):
        if not self.disable_echo:
            print(*args, file=self.stderr, flush=True, **kwargs)

    def echo(self, *args, **kwargs):
        if not self.disable_echo:
            print(*args, file=self.stdout, flush=True, **kwargs)

    def err(self, *args, **kwargs):
        if not self.disable_echo:
            print(*args, file=self.stderr, flush=True, **kwargs)
        logger.warning(*args, **kwargs)

    def exit(self, code):
        # To be overridden in unittests.
        sys.exit(code)

    @classmethod
    def from_ini(
        cls, loaded_from: str, conf: ConfigParser
    ) -> t.Tuple["GlobalConfig", t.List[Wallet]]:
        sect = conf["default"]
        c = cls(
            loaded_from,
            conf,
            sect.get("bitcoind_json_url"),
            sect.get("default_wallet"),
        )
        wallets = []

        for key in conf.sections():
            if key == "default":
                continue

            net_name = "mainnet"
            WalletClass = {"coldcard": CCWallet}.get(key.split("-")[0])

            if not WalletClass:
                raise ValueError(f"unrecognized wallet type for {key}")

            if conf[key].get("xpub", "").startswith("tpub"):
                net_name = TESTNET
            rpc = c.rpc(net_name=net_name)

            try:
                wallets.append(WalletClass.from_ini(key, rpc, conf))
            except Exception:
                msg = f"Unable to read config section '{key}'"
                logger.exception(msg)
                c.err(msg)

        return (c, wallets)

    @classmethod
    def write_blank(cls, outfile: t.IO, bitcoind_json_url: Op[str] = ""):
        """Write a blank configuration file."""
        outfile.write(_get_blank_conf(bitcoind_json_url))
        p = Path(outfile.name)

        # Ensure that the created file is only readable by the owner.
        if p.exists():
            # FIXME make cross-platform
            _sh(f"chmod 600 {p}")

    def add_new_wallet(self, w: Wallet):
        logger.info("Adding new wallet to config: %s", w.as_ini_dict)
        self.raw_config[w.name] = w.as_ini_dict

    def write(self):
        """Save the contents of this config to an INI file on disk."""
        if _is_pass_path(self.loaded_from):
            to_path = self.loaded_from.split(PASS_PREFIX)[-1]
            passobj = Pass()
            content = io.StringIO()
            self.raw_config.write(content)
            content.seek(0)
            passobj.write(to_path, content.read())

        elif self.loaded_from.endswith(".gpg"):
            gpg = GPG()
            content = io.StringIO()
            self.raw_config.write(content)
            content.seek(0)
            gpg.write(self.loaded_from, content.read())

        else:
            with open(self.loaded_from, "w") as f:
                self.raw_config.write(f)

        logger.info(f"Wrote configuration to {self.loaded_from}")


def _get_blank_conf(bitcoind_json_url: Op[str] = "") -> str:
    return textwrap.dedent(
        f"""
        [default]

        # If blank, this will default to something like
        #   http://localhost:8332
        # You can specify non-localhosts like
        #   http://your_rpc_user:rpcpassword@some_host:8332/
        bitcoind_json_url = {bitcoind_json_url or ''}

        # This corresponds to one of the wallet sections listed below,
        # and will be used for commands where a single wallet is required
        # but unspecified.
        default_wallet =
        """
    )


def _get_stdout(*args, **kwargs) -> t.Tuple[int, bytes]:
    """Return (returncode, stdout as bytes)."""
    kwargs["shell"] = True
    kwargs["capture_output"] = True
    result = subprocess.run(*args, **kwargs)
    return (result.returncode, result.stdout)


def _sh(*args, **kwargs) -> subprocess.CompletedProcess:
    kwargs.setdefault("shell", True)
    return subprocess.run(*args, **kwargs)


def rpc_wallet_create(rpc: BitcoinRPC, wall: Wallet):
    try:
        rpc.createwallet(wall.bitcoind_name, True)
    except JSONRPCError as e:
        if e.error.get("code") != -4:  # type: ignore
            # Wallet already exists; ok.
            raise


def get_utxos(rpcw: BitcoinRPC) -> t.Dict[str, "UTXO"]:
    return {
        u.address: u
        for u in UTXO.from_listunspent(rpcw.listunspent(0))  # includes unconfirmed
    }


def _prepare_send(
    config: GlobalConfig,
    rpcw: BitcoinRPC,
    to_address: str,
    amount: str,
    spend_from: Op[t.List[str]],
):
    vins = []

    if spend_from:
        utxos = UTXO.from_listunspent(rpcw.listunspent(0))
        addrs = {u.address for u in utxos}
        unknown_addrs = set(spend_from) - addrs

        for addr in unknown_addrs:
            # TODO should fail?
            _warn(f"WARNING: address '{addr}' not in wallet")

        for u in utxos:
            if u.address in spend_from:
                vins.append({"txid": u.txid, "vout": u.vout})

    try:
        result = rpcw.walletcreatefundedpsbt(
            vins,  # inputs for txn (manual coin control)
            [{to_address: amount}],
            0,  # locktime
            {"includeWatching": True},  # options; 'feeRate'?
            True,  # bip32derivs - include BIP32 derivation paths for pubkeys if known
        )
    except Exception as e:
        # error code: -5 indicates bad address; handle that.
        if e.error.get("code") == -5:  # type: ignore
            config.info(f"Bad address specified: {e}")
            return False
        raise

    nowstr = datetime.datetime.now().strftime("%Y%m%d-%H%M")
    filename = f"unsigned-{nowstr}.psbt"
    Path(filename).write_bytes(base64.b64decode(result["psbt"]))

    config.echo(result)
    config.echo(f"Wrote PSBT to {filename} - sign with coldcard")

    return filename


def _psbt_to_tx_hex(rpcw: BitcoinRPC, psbt_path: Path) -> str:
    content: bytes = psbt_path.read_bytes().strip()

    # Handle signed TX as raw binary.
    if content[0:5] == b"psbt\xff":
        to_ascii = base64.b64encode(content).decode()
        # TODO handle errors
        return rpcw.finalizepsbt(to_ascii)["hex"]

    # Handle signed TX as base64.
    elif content[0:6] == b"cHNidP":
        # TODO handle errors
        return rpcw.finalizepsbt(content.decode())["hex"]

    # Handle signed TX as hex.
    elif _can_decode_transaction(rpcw, content.decode()):
        return content.decode()

    raise ValueError("unrecognized signed PSBT format")


def _can_decode_transaction(rpc: BitcoinRPC, tx_hex: str) -> bool:
    try:
        got = rpc.decoderawtransaction(tx_hex)
        assert got["txid"]
    except Exception:
        return False
    return True


def _confirm_broadcast(config: GlobalConfig, rpcw: BitcoinRPC, hex_val: str) -> bool:
    """Display information about the transaction to be performed and confirm."""
    info = rpcw.decoderawtransaction(hex_val)
    outs: t.List[t.Tuple[str, Decimal]] = []

    for out in info["vout"]:
        addrs = ",".join(out["scriptPubKey"]["addresses"])
        outs.append((addrs, out["value"]))

    config.info("About to send a transaction:\n")
    for o in outs:
        try:
            addr_info = rpcw.getaddressinfo(o[0])
        except Exception:
            # TODO handle this
            raise

        yours = addr_info["ismine"] or addr_info["iswatchonly"]
        yours_str = "  (your address)" if yours else ""
        config.info(f" -> {o[0]}  ({o[1]} BTC){yours_str}")

    config.info("\n")

    inp = input("Look okay? [y/N]: ").strip().lower()

    if inp != "y":
        return False
    return True


def _broadcast(config: GlobalConfig, rpcw: BitcoinRPC, tx_hex: str):
    config.info(rpcw.sendrawtransaction(tx_hex))


def _wallet_from_input(inp: str, rpc: BitcoinRPC) -> Wallet:
    inppath = Path(inp)
    if inp == "-":
        content = io.StringIO(sys.stdin.read())
    elif inppath.exists():
        content = io.StringIO(Path(inp).read_text())
    else:
        raise ValueError(f"input path {inppath} can't be read")

    return CCWallet.from_io(content, rpc)


@cli.cmd
def setup(public_wallet_data: str, rpc_url: str = ""):
    """
    Run initial setup for a wallet. This creates the local configuration file (if
    one doesn't already exist) and populates a watch-only wallet in Core.

    Args:
        public_wallet_data: path to Coldcard's public.txt or '-' to read from stdin
        rpc_url: URL to Bitcoin Core JSON RPC, e.g. 'http://user:pass@host:8332'
    """
    rpc = discover_rpc(url=rpc_url)

    if not rpc:
        _warn("Bitcoin Core JSON RPC server could not be detected")
        _warn("Please ensure you are running Bitcoin Core locally, or pass an RPC")
        _warn("address like '--bitcoind-rpc-url http://user:pass@host:8332'.")
        sys.exit(1)

    (config, _) = _get_config(bitcoind_json_url=rpc.url, require_wallets=False)
    rpc = config.rpc()

    wall = _wallet_from_input(public_wallet_data, rpc)

    config.info(
        check_line(
            f"Adding new wallet '{wall.name}' to config at '{config.loaded_from}'"
        )
    )
    config.add_new_wallet(wall)
    config.write()

    rpc_wallet_create(rpc, wall)

    rpcw = config.rpc(wall)
    import_res = rpcw.importmulti(*wall.importmulti_args())

    if not all(i["success"] for i in import_res):
        config.err(
            f"Warning: failed to import some descriptors into Core: {import_res}"
        )

    rpcw = config.rpc(wall, timeout=10000)
    scan_result = {}  # type: ignore
    scan_thread = threading.Thread(
        target=_run_scantxoutset,
        args=(config.rpc(wall), wall.scantxoutset_args(), scan_result),
    )
    scan_thread.start()
    spinner = Spinner()

    while scan_thread.is_alive():
        sys.stderr.write(
            f"\r {spinner.spin()}  -> scanning the UTXO set for balance [few minutes] ",
        )
        time.sleep(0.2)

    config.info("\n" + check_line("Scan of UTXO set complete!"))

    unspents = scan_result["result"]["unspents"]
    bal = sum([i["amount"] for i in unspents])
    bal_str = yellow(bold(f"{bal} BTC"))
    bal_count = yellow(bold(f"{len(unspents)} UTXOs"))
    config.info(
        check_line(f"Found an existing balance of {bal_str} across {bal_count}")
    )

    rescan_begin_height = min([i["height"] for i in unspents])
    config.info(
        info_line(
            f"Beginning chain rescan from {rescan_begin_height} [minutes to hours]"
        )
    )
    rescan_thread = threading.Thread(
        target=_run_rescan, args=(config.rpc(wall), rescan_begin_height), daemon=True
    )
    rescan_thread.start()

    time.sleep(1)

    scan_info = rpcw.getwalletinfo()["scanning"]
    spinner = Spinner()

    while scan_info:
        sys.stdout.write(
            f"\r {spinner.spin()} scan progress: {scan_info['progress'] * 100:.2f}%   "
        )
        time.sleep(0.5)
        scan_info = rpcw.getwalletinfo()["scanning"]

    name = yellow(bold(wall.name))
    config.info("\n" + check_line(f"Scan complete. Wallet {name} ready to use.\n"))
    config.info(
        info_line(f"Hint: check out your UTXOs with `coldcore -w {wall.name} balance`")
    )
    return True


def _run_scantxoutset(rpcw: BitcoinRPC, args, result):
    try:
        result["result"] = rpcw.scantxoutset(*args)
    except socket.timeout:
        logger.exception("socket timed out during txoutsetscan (this is expected)")


def _run_rescan(rpcw: BitcoinRPC, begin_height: int):
    try:
        rpcw.rescanblockchain(begin_height)
    except socket.timeout:
        logger.exception("socket timed out during rescan (this is expected)")


@cli.cmd
def watch():
    """Watch activity related to your wallets."""
    (config, (wall, *_)) = _get_config()
    rpcw = config.rpc(wall)

    utxos = get_utxos(rpcw)
    config.echo(f"Watching wallet {config.wallet_name}")

    while True:
        new_utxos = get_utxos(rpcw)

        spent_addrs = utxos.keys() - new_utxos.keys()
        new_addrs = new_utxos.keys() - utxos.keys()

        for addr in spent_addrs:
            u = utxos[addr]
            config.echo(f"Saw spend: {u.address} ({u.amount})")

        for addr in new_addrs:
            u = new_utxos[addr]
            config.echo(f"Got new UTXO: {u.address} ({u.amount})")

        was_zeroconf = [new_utxos[k] for k, v in utxos.items() if v.num_confs == 0]
        finally_confed = [utxo for utxo in was_zeroconf if utxo.num_confs > 0]

        for u in finally_confed:
            config.echo(f"UTXO confirmed! {u.address} ({u.amount})")

        utxos = new_utxos
        time.sleep(0.1)


@cli.cmd
def balance():
    """Check your wallet balances."""
    (config, (wall, *_)) = _get_config()
    rpcw = config.rpc(wall)
    utxos = UTXO.from_listunspent(rpcw.listunspent(0))  # includes unconfirmed
    utxos = sorted(utxos, key=lambda u: -u.num_confs)

    for utxo in utxos:
        config.echo(f"{utxo.address:<40} {utxo.num_confs:>10} {utxo.amount}")

    amt = sum(u.amount for u in utxos)
    config.echo(f"total: {len(utxos)} ({amt})")
    return True


@cli.cmd
def prepare_send(to_address: str, amount: str, spend_from: str = ""):
    """
    Prepare a sending PSBT.

    Args:
        to_address: which address to send to
        amount: amount to send in BTC
        spend_from: comma-separated addresses to pull unspents from as inputs
    """
    (config, (wall, *_)) = _get_config()
    rpcw = config.rpc(wall)
    spend_from_list = spend_from.split(",") if spend_from else None

    return _prepare_send(config, rpcw, to_address, amount, spend_from_list)


@cli.cmd
def broadcast(signed_psbt_path: Path):
    """Broadcast a signed PSBT."""
    (config, (wall, *_)) = _get_config()
    rpcw = config.rpc(wall)
    hex_val = _psbt_to_tx_hex(rpcw, signed_psbt_path)
    assert hex_val

    if not _confirm_broadcast(config, rpcw, hex_val):
        config.echo("Aborting transaction! Doublespend the inputs!")
        return

    return _broadcast(config, rpcw, hex_val)


@cli.cmd
def newaddr():
    (config, (wall, *_)) = _get_config()
    rpcw = config.rpc(wall)
    config.echo(rpcw.getnewaddress())


@cli.cmd
def ui():
    """Start a curses UI."""
    config, walls = _get_config()
    config.disable_echo = True
    start_ui(config, walls)


class Pass:
    """Access to pass, the password store."""

    @classmethod
    def write(cls, path: str, content: str) -> bool:
        """Return True if write successful."""
        # TODO maybe detect whether or not we're overwriting and warn
        _err(f"Requesting to write to pass: {path}")
        logger.info(f"Writing to pass: {path}")
        proc = subprocess.Popen(
            f"pass insert -m -f {path}",
            shell=True,
            stdin=subprocess.PIPE,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        proc.communicate(content.encode())
        return proc.returncode == 0

    @classmethod
    def read(self, path: str, action: str = "Requesting to read") -> Op[str]:
        """Return None if path doesn't exist."""
        _err(f"{action} from pass: {path}")
        logger.info(f"Reading from pass: {path}")
        retcode, conf_str = _get_stdout(f"pass show {path}")
        if retcode != 0:
            return None
        return conf_str.decode().strip()


class GPG:
    """Access to GPG."""

    def __init__(self):
        self.gpg_path: Op[str] = _get_gpg_command()

    @property
    def system_has_gpg(self):
        return bool(self.gpg_path)

    @classmethod
    def write(self, path: str, content: str) -> bool:
        """Return True if write successful."""
        logger.info(f"Writing to GPG: {path}")
        gpg_key = os.environ.get("COLDCORE_GPG_KEY", _find_gpg_default_key())
        gpg_mode = f"-e -r {gpg_key}"

        if not gpg_key:
            _err(
                "No default-key present; encrypting to GPG using a passphrase",
            )
            gpg_mode = "-c"

        with open(path, "w") as f:
            proc = subprocess.Popen(
                f"gpg {gpg_mode}", shell=True, stdout=f, stdin=subprocess.PIPE
            )
            proc.communicate(content.encode())

        return proc.returncode == 0

    @classmethod
    def read(self, path: str) -> Op[str]:
        p = Path(path)
        if not p.exists():
            logger.warning(f"tried to read from GPG path {p} that doesn't exist")
            return None

        logger.info(f"Reading from GPG: {path}")
        (retcode, content) = _get_stdout(f"gpg -d {p}")

        if retcode == 0:
            return content.decode().strip()

        logger.warning(f"failed to read GPG path {p}, returncode: {retcode}")
        return None


def _find_gpg_default_key() -> Op[str]:
    """Get the GPG default-key to encrypt with."""
    gpg_conf_path = Path.home() / ".gnupg" / "gpg.conf"
    gpg_conf_lines = []
    try:
        gpg_conf_lines = gpg_conf_path.read_text().splitlines()
    except FileNotFoundError:
        pass

    default_key_line = None
    try:
        [default_key_line] = [
            line for line in gpg_conf_lines if line.startswith("default-key ")
        ]
    except ValueError:
        pass

    if not default_key_line:
        logger.warning(
            f"Must set `default-key` in {gpg_conf_path} or "
            "use COLDCORE_GPG_KEY envvar, otherwise don't know "
            "what to encrypt with.",
        )
        return None

    return default_key_line.split("default-key ")[-1]


CONFIG_DIR = Path.home() / ".config" / "coldcore"
DEFAULT_CONFIG_PATH = CONFIG_DIR / "config.ini"


# TODO move config backend to prefix system


def _get_gpg_command() -> Op[str]:
    """Find the version, if any, of GPG installed."""
    if _get_stdout("which gpg2")[0] == 0:
        return "gpg2"
    elif _get_stdout("which gpg")[0] == 0:
        return "gpg"
    return None


def get_path_for_new_config() -> str:
    # FIXME: prefix backends
    # gpg = _get_gpg_command()
    # if gpg:
    #     return CONFIG_DIR / "config.ini.gpg"
    return str(CONFIG_DIR / "config.ini")


def find_default_config() -> Op[str]:
    """
    Find an existing default configuration file. We do this
    (vs. get_path_for_new_config) because a user may have created a configuration file
    and then installed GPG.
    """
    # Prefer GPG configs
    for ext in (".gpg", ""):
        path = CONFIG_DIR / ("config.ini" + ext)
        if path.exists():
            return str(path)
    return None


def _is_pass_path(p: str) -> bool:
    return p.startswith(PASS_PREFIX)


def _get_config(
    wallet_names: Op[t.List[str]] = None,
    bitcoind_json_url: str = "",
    require_wallets: bool = True,
) -> t.Tuple[GlobalConfig, t.List[Wallet]]:
    """
    Load in coldcore config from some source.

    Return the config and a list of loaded wallets. The config's default_wallet will
    be the first item in the list.
    """
    confp = ConfigParser()
    conf_path = cli.args.config or os.environ.get(
        "COLDCORE_CONFIG", find_default_config()
    )

    if (
        conf_path
        and not _is_pass_path(conf_path)
        and not conf_path.startswith(str(DEFAULT_CONFIG_PATH))
        and not Path(conf_path).exists()
    ):
        print(f"Configuration not readable from {conf_path}")
        sys.exit(1)

    # TODO this is okay for right now, but maybe think about making this less
    # automatic and more explicit.
    if not conf_path:
        conf_path = get_path_for_new_config()

    if not CONFIG_DIR.exists():
        # FIXME macOS
        CONFIG_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)

    # Optionally, read the configuration from `pass`.
    if _is_pass_path(conf_path):
        passobj = Pass()
        passpath = conf_path.split(PASS_PREFIX, 1)[-1]
        contents = passobj.read(passpath, action="Requesting to load configuration INI")

        if not contents:
            msg = f"Creating blank configuration at {conf_path}"
            logger.info(msg)
            print(msg)
            contents = _get_blank_conf(bitcoind_json_url)
            # config doesn't exist, so insert it
            if not passobj.write(passpath, contents):
                print(f"Failed to write new configuration to {conf_path}")
                sys.exit(1)

        confp.read_string(contents)

    # Or read from GPG
    elif conf_path.endswith(".gpg"):
        gpg = GPG()
        _err(f"Reading configuration from {conf_path} with GPG")
        contents = gpg.read(conf_path)

        if not contents:
            msg = f"Creating blank configuration at {conf_path}"
            logger.info(msg)
            print(msg)
            contents = _get_blank_conf(bitcoind_json_url)
            # config doesn't exist, so insert it
            gpg.write(conf_path, contents)

        confp.read_string(contents)

    # Or just read it from some file path.
    else:
        if not Path(conf_path).exists():
            logger.info(f"Creating blank configuration at {conf_path}")

            _warn("WARNING: creating an unencrypted configuration file.")
            _warn("Please consider installing GPG and/or pass to support config file ")
            _warn("encryption. If someone gains access to your xpubs, they can ")
            _warn("see all of your addresses.")

            with open(conf_path, "w") as f:
                GlobalConfig.write_blank(f, bitcoind_json_url)

        confp.read(conf_path)

    (conf, wallet_confs) = GlobalConfig.from_ini(conf_path, confp)

    logger.debug("loaded with config: %s", conf)
    logger.debug("loaded with wallets: %s", wallet_confs)

    unrecog_wallets = set(wallet_names or []) - set(w.name for w in wallet_confs)
    if unrecog_wallets:
        conf.err("Unrecognized wallet names: {', '.join(unrecog_wallets)}")
        conf.exit(1)

    if wallet_names:
        wallet_confs = [w for w in wallet_confs if w.name in wallet_names]

    default_wallet = cli.args.wallet or conf.default_wallet

    # Return the default wallet first.
    wallet_confs = sorted(
        wallet_confs, key=lambda w: w.name == default_wallet, reverse=True
    )

    if require_wallets and not wallet_confs:
        conf.err("At least one wallet config is required but none were found.")
        conf.err("Try running `coldcore setup --help` to set up a wallet")
        sys.exit(1)

    return (conf, wallet_confs)


def main():
    cli.parse_for_run()
    log_path = setup_logging()
    cli.run()

    if log_path:
        _warn(
            f"WARNING: remove logfiles at {log_path} to prevent leaking sensitive data",
        )


if __name__ == "__main__":
    main()